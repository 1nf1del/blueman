#!/usr/bin/python

# Copyright (C) 2008 Valmantas Paliksa <walmis at balticum-tv dot lt>
# Copyright (C) 2008 Tadas Dailyda <tadas at dailyda dot com>
#
# Licensed under the GNU General Public License Version 3
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
# 

import sys
from subprocess import *
import os.path
import pynotify
import dbus
import dbus.glib
import gobject
import gtk

#support running uninstalled
_dirname = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
if os.path.exists(os.path.join(_dirname,"ChangeLog")):
	sys.path.insert(0, _dirname)

from blueman.main.applet.Transfer import Transfer
from blueman.main.SignalTracker import SignalTracker
from blueman.Functions import *
from blueman.main.applet.BluezAgent import BluezAgent
from blueman.main.applet.DbusService import DbusService
from blueman.main.applet.NetworkManager import NetworkManager
from blueman.Constants import *
import blueman.bluez as Bluez
from blueman.gui.CommonUi import show_about_dialog
import gettext
_ = gettext.gettext




class BluemanApplet:

	def __init__(self):
		setup_icon_path()
		if not pynotify.init("Blueman"):
			print 'Error: Failed to init pynotify'
		
		self.Signals = SignalTracker()
		self.Agents = []
		self.status_icon = gtk.StatusIcon()
		self.status_icon = gtk.status_icon_new_from_icon_name("bluetooth")
		self.status_icon.connect('popup-menu', self.on_popup_menu)
		self.build_popup_menu()
		
		#determine if icon should be visible (in case adapters are present)
		self.bus = dbus.SystemBus()
		self.bus.watch_name_owner('org.bluez', self.on_dbus_name_owner_change)
		self.manager_init()

		
		
		DbusService(self)
		
		self.Transfer = Transfer(self)
		
		gtk.main()
		
	def manager_init(self):
		try:
			for agent in self.Agents:
				agent.remove_from_connection()
				self.Agents = []
			
			self.Signals.DisconnectAll()
			self.Manager = Bluez.Manager('gobject')
			self.NM = NetworkManager(self)
			self.Signals.Handle("bluez", self.Manager, self.on_adapter_removed, 'AdapterRemoved')
			self.Signals.Handle("bluez", self.Manager, self.on_adapter_added, 'AdapterAdded')
			adapters = self.Manager.ListAdapters()
			self.status_icon.set_visible(adapters != [])
			for adapter in adapters:
				self.register_agent(adapter)
		except dbus.exceptions.DBusException, e:
			print e
			self.Manager = None
			self.NM = None
			self.status_icon.set_visible(False)
			print 'Bluez DBus API not available. Listening for DBus name ownership changes'
			
	def register_agent(self, adapter):
		try:
			agent = BluezAgent(self, adapter.GetObjectPath())
			adapter.GetInterface().RegisterAgent(agent.dbus_path, 'DisplayYesNo')
			self.Agents.append(agent)

		except:
			print 'Failed to register agent'
		
	def on_dbus_name_owner_change(self, owner):
		print 'org.bluez owner changed to ', owner
		if owner == '':
			self.Manager = None
			self.status_icon.set_visible(False)
		elif self.Manager == None:
			self.manager_init()
		
	def on_adapter_added(self, path):
		print 'Adapter added ', path
		self.status_icon.set_visible(True)
		self.register_agent(self, path)
		
	def on_adapter_removed(self, path):
		print 'Adapter removed ', path
		if self.Manager.ListAdapters() == []:
			self.status_icon.set_visible(False)
			
	def build_popup_menu(self):
		menu_items = []
		menu_items += [create_menuitem(_('Setup new device')+'...', get_icon("gtk-new", 16))]
		menu_items[-1].connect('activate', self.on_setup_new)
		menu_items += [create_menuitem(_('Send files to device')+'...', get_icon("blueman-send-file", 16))]
		menu_items[-1].connect('activate', self.on_send)
		if OBEX_BROWSE_AVAILABLE:
			menu_items += [create_menuitem(_('Browse files on device')+'...', get_icon("gtk-open", 16))]
			menu_items[-1].connect('activate', self.on_browse)
		menu_items += [gtk.SeparatorMenuItem()]
		menu_items += [gtk.MenuItem(_('Devices')+'...', False)]
		menu_items[-1].connect('activate', self.on_devices)
		
		menu_items += [create_menuitem(_('Adapters')+'...', get_icon("blueman-device", 16))]
		menu_items[-1].connect('activate', self.on_adapters)
		
		menu_items += [create_menuitem(_('Local services')+'...', get_icon("gtk-preferences", 16))]
		menu_items[-1].connect('activate', self.on_local_services)
		
		menu_items += [gtk.SeparatorMenuItem()]
		menu_items += [gtk.ImageMenuItem(gtk.STOCK_ABOUT)]
		menu_items[-1].connect('activate', self.on_about)
		
		self.menu = gtk.Menu()
		for menu_item in menu_items:
			self.menu.append(menu_item)
			menu_item.show()
			
	def on_popup_menu(self, status_icon, button, activate_time):
		self.menu.popup(None, None, gtk.status_icon_position_menu,
						button, activate_time, status_icon)
	
	def on_setup_new(self, menu_item):
		spawn('blueman-wizard')
		
	def on_send(self, menu_item):
		spawn('blueman-sendto')
		
	def on_browse(self, menu_item):
		spawn('blueman-browse')
		
	def on_devices(self, menu_item):
		spawn('blueman-manager')
		
	def on_adapters(self, menu_item):
		spawn('blueman-adapters')
		
	def on_local_services(self, menu_item):
		spawn('blueman-services')
		
	def on_about(self, menu_item):
		show_about_dialog('Blueman '+_('applet'))
	
	def build_passkey_dialog(self, device_alias, dialog_msg, is_numeric):
		def on_insert_text(editable, new_text, new_text_length, position):
			if not new_text.isdigit():
				editable.stop_emission("insert-text")
		
		builder = gtk.Builder()
		builder.add_from_file(UI_PATH +"/applet-passkey.ui")
		dialog = builder.get_object("dialog")
		dialog.props.icon_name = "blueman"
		dev_name = builder.get_object("device_name")
		dev_name.set_markup("<b>"+device_alias+"</b>")
		msg = builder.get_object("message")
		msg.set_text(dialog_msg)
		pin_entry = builder.get_object("pin_entry")
		show_input = builder.get_object("show_input_check")
		if (is_numeric):
			pin_entry.set_max_length(6)
			pin_entry.set_width_chars(6)
			pin_entry.connect("insert-text", on_insert_text)
			show_input.hide()
		else:
			pin_entry.set_max_length(16)
			pin_entry.set_width_chars(16)
			pin_entry.set_visibility(False)
		show_input.connect("toggled", lambda x: pin_entry.set_visibility(x.props.active))
		accept_button = builder.get_object("accept")
		pin_entry.connect("changed", lambda x: accept_button.set_sensitive(x.get_text() != ''))
		
		return (dialog, pin_entry)
	
	def show_notification(self, summary, message, timeout=-1, actions= None, actions_cb=None):
		def on_notification_closed(n):
			actions_cb(n, 'default')
			n.disconnect(closed_sig)
		
		n = pynotify.Notification(summary, message)
		if actions:
			for action in actions:
				n.add_action(action[0], action[1], actions_cb)
			n.add_action('default', 'Default Action', actions_cb)
		closed_sig = n.connect('closed', on_notification_closed)
		if timeout != -1:
			n.set_timeout(timeout)
		if self.status_icon.get_visible():
			screen, area, orientation = self.status_icon.get_geometry()
			n.set_hint("x", area.x + area.width/2)
			n.set_hint("y", area.y + area.height/2)
		n.show()
		return n

BluemanApplet()

